---
import Layout from '@/layouts/main.astro';
import { ArrowLeft, Calendar, Clock3 } from 'lucide-react';
import { withBase } from '@/lib/utils';
import type { PostEntry } from '@/lib/content';
import { estimateReadingTime } from '@/lib/readingTime';

type Props = {
  post: PostEntry;
  backHref: '/blog' | '/news';
  backLabel: string;
  showReadingTime?: boolean;
};

const { post, backHref, backLabel, showReadingTime = false } = Astro.props as Props;
const { Content } = await post.render();
---

<Layout title={`${post.data.title} - AI Colleagues`}>
  <article class="pt-4 pb-8 md:pt-6 md:pb-12">
    <div class="container mx-auto px-4">
      <div class="max-w-5xl mx-auto">
        <a
          href={withBase(backHref)}
          class="inline-flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors mb-6"
        >
          <ArrowLeft class="h-4 w-4" />
          {backLabel}
        </a>
        <header class="mb-10 border-b pb-8 text-center">
          <div class="flex items-center justify-center gap-3 text-sm text-muted-foreground mb-4">
            <span class="inline-flex items-center gap-1">
              <Calendar class="h-4 w-4" />
              {post.data.pubDate.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
                year: 'numeric',
              })}
            </span>
            {showReadingTime ? (
              <span class="inline-flex items-center gap-1">
                <Clock3 class="h-4 w-4" />
                {estimateReadingTime(post.body).text}
              </span>
            ) : null}
            <span class="inline-block px-2 py-1 rounded-full bg-primary/10 text-primary text-xs font-medium">
              {post.data.category}
            </span>
          </div>
          <h1 class="text-3xl md:text-5xl font-bold mb-4">{post.data.title}</h1>
          <p class="text-xl text-muted-foreground">{post.data.summary}</p>
        </header>
      </div>

      <div class="max-w-3xl mx-auto">
        <div class="prose prose-lg dark:prose-invert max-w-none">
          <Content />
        </div>
      </div>
    </div>
  </article>

  <script>
    const MERMAID_BLOCK_SELECTOR = 'pre[data-language="mermaid"]';
    const MERMAID_CONTAINER_CLASS = 'post-mermaid';
    /** @type {Promise<import('mermaid').default> | undefined} */
    let mermaidPromise;

    const getMermaidTheme = () =>
      document.documentElement.classList.contains('dark') ? 'dark' : 'default';

    const convertMermaidCodeBlocks = () => {
      const codeBlocks = document.querySelectorAll(MERMAID_BLOCK_SELECTOR);
      if (codeBlocks.length === 0) return false;

      let createdContainers = 0;

      for (const block of codeBlocks) {
        const definition = block.textContent?.trim();
        if (!definition) continue;

        const container = document.createElement('div');
        container.className = MERMAID_CONTAINER_CLASS;
        container.dataset.definition = definition;

        block.replaceWith(container);
        createdContainers += 1;
      }

      return createdContainers > 0;
    };

    const getMermaid = async () => {
      if (!mermaidPromise) {
        mermaidPromise = import('mermaid').then((module) => module.default);
      }

      return mermaidPromise;
    };

    const renderMermaidDiagrams = async () => {
      const diagrams = Array.from(document.querySelectorAll(`.${MERMAID_CONTAINER_CLASS}`));
      if (diagrams.length === 0) return;

      const mermaid = await getMermaid();
      mermaid.initialize({
        startOnLoad: false,
        securityLevel: 'strict',
        theme: getMermaidTheme(),
      });

      for (const diagram of diagrams) {
        const definition = diagram.dataset.definition;
        if (!definition) continue;

        diagram.removeAttribute('data-processed');
        diagram.textContent = definition;
      }

      await mermaid.run({ nodes: diagrams });
    };

    const initMermaid = async () => {
      const hasMermaidBlocks = convertMermaidCodeBlocks();
      if (!hasMermaidBlocks) return;

      await renderMermaidDiagrams();

      let isDarkMode = document.documentElement.classList.contains('dark');
      const observer = new MutationObserver(async () => {
        const nextIsDarkMode = document.documentElement.classList.contains('dark');
        if (nextIsDarkMode === isDarkMode) return;
        isDarkMode = nextIsDarkMode;
        await renderMermaidDiagrams();
      });

      observer.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['class'],
      });

      window.addEventListener('beforeunload', () => observer.disconnect(), { once: true });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        void initMermaid();
      });
    } else {
      void initMermaid();
    }
  </script>

  <style is:global>
    .prose .post-mermaid {
      margin: 1.5rem 0;
      border: 1px solid hsl(var(--border));
      border-radius: 0.75rem;
      background-color: hsl(var(--card));
      padding: 1rem;
      overflow-x: auto;
    }

    .prose .post-mermaid svg {
      display: block;
      width: auto;
      max-width: 100%;
      height: auto;
      margin: 0 auto;
    }

    .prose [data-footnote-ref] {
      text-decoration: none;
      font-weight: 600;
    }

    .prose [data-footnotes] {
      margin-top: 2.5rem;
      font-size: 0.95em;
    }

    .prose [data-footnotes] ol {
      padding-left: 1.25rem;
    }

    .prose [data-footnotes] li {
      margin-top: 0.5rem;
    }

    .prose [data-footnote-backref] {
      text-decoration: none;
      margin-left: 0.25rem;
    }
  </style>
</Layout>
